use std::io; /* 4294967040 */
use simple::*; /* 4294967040 */
pub mod simple; /* 4294967040 */

fn main() {
    let secret_key /* pat 4294967040 */ =
        ((get_secret_key /* 4294967040 */)() /* 4294967040 */);
    let mut buffer /* pat 4294967040 */ =
        ((String::new /* 4294967040 */)() /* 4294967040 */);
    println!("Please input a 8 byte message");
    let _ /* pat 4294967040 */ =
        (((io::stdin /* 4294967040 */)() /* 4294967040
             */).read_line((&mut (buffer /* 4294967040 */) /* 4294967040 */))
            /* 4294967040 */);
    let mut message /* pat 4294967040 */ =
        ([(0u8 /* 4294967040 */); (8 /* 4294967040 */)] /* 4294967040 */);
    (for i /* pat 4294967040 */ in
         ((0 /* 4294967040 */)..(8 /* 4294967040 */) /* 4294967040 */) {
         (if ((i /* 4294967040 */) <
                 ((buffer /* 4294967040 */).len() /* 4294967040 */) /*
                 4294967040 */) {
              (((message /* 4294967040 */)[(i /* 4294967040 */)] /* 4294967040
                   */) =
                  (((buffer /* 4294967040 */).as_bytes() /* 4294967040
                       */)[(i /* 4294967040 */)] /* 4294967040 */) /*
                  4294967040 */);
          } /* block 4294967040 */ /* 4294967040 */)
     } /* block 4294967040 */ /* 4294967040 */)
    let cipher_text /* pat 4294967040 */ =
        ((encrypt /* 4294967040
             */)((&(message /* 4294967040 */) /* 4294967040 */),
                 (&(secret_key /* 4294967040 */) /* 4294967040 */)) /*
            4294967040 */);
    let text /* pat 4294967040 */ =
        ((decrypt /* 4294967040
             */)((&(cipher_text /* 4294967040 */) /* 4294967040 */),
                 (&(secret_key /* 4294967040 */) /* 4294967040 */)) /*
            4294967040 */);
    assert!(message == & text [..]);
    println!("message: {:?}", message);
    println!("ciphertext: {:?}", cipher_text);
} /* block 4294967040 */ /* 4294967040 */
