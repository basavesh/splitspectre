BASH: USE snip "use std::num::Wrapping;"
BASH: USE snip "std::num::Wrapping"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: Struct snip "pub struct $name(pub $repr);"
BASH: USE snip "use std::io;"
BASH: Mod snip "pub mod simple {\n    use rand::Rng;\n    use secret_integers::*;\n\n/// classify vector of u8s into U8s\nfn classify_u8s(v: &[u8]) -> Vec<U8> {\n    v.iter().map(|x| U8::classify(*x)).collect()\n}\n\n/// declassify vector of U8s into u8s\nfn declassify_u8s(v: &[U8]) -> Vec<u8> {\n    v.iter().map(|x| U8::declassify(*x)).collect()\n}\n\npub fn get_secret_key() -> Vec<U8> {\n    let random_bytes = rand::thread_rng().gen::<[u8; 8]>();\n    return classify_u8s(&random_bytes);\n}\n\npub fn encrypt(msg: &[u8], sk: &[U8]) -> Vec<u8> {\n    let mut new_block = [U8::zero(); 8];\n    let classified_msg = classify_u8s(msg);\n    for i in 0..8 {\n        new_block[i] = classified_msg[i] ^ sk[i];\n    }\n    return declassify_u8s(&new_block);\n}\n\npub fn decrypt(cipher: &[u8], sk: &[U8]) -> Vec<u8> {\n    let mut new_block = [U8::zero(); 8];\n    let classified_cipher = classify_u8s(cipher);\n    for i in 0..8 {\n        new_block[i] = classified_cipher[i] ^ sk[i];\n    }\n    return declassify_u8s(&new_block);\n}\n\n}"
BASH: USE snip "use rand::Rng;"
BASH: Fn snip "fn classify_u8s(v: &[u8]) -> Vec<U8> {\n    v.iter().map(|x| U8::classify(*x)).collect()\n}"
BASH: Fn snip "fn declassify_u8s(v: &[U8]) -> Vec<u8> {\n    v.iter().map(|x| U8::declassify(*x)).collect()\n}"
BASH: Fn snip "pub fn get_secret_key() -> Vec<U8> {\n    let random_bytes = rand::thread_rng().gen::<[u8; 8]>();\n    return classify_u8s(&random_bytes);\n}"
BASH: Fn snip "pub fn encrypt(msg: &[u8], sk: &[U8]) -> Vec<u8> {\n    let mut new_block = [U8::zero(); 8];\n    let classified_msg = classify_u8s(msg);\n    for i in 0..8 {\n        new_block[i] = classified_msg[i] ^ sk[i];\n    }\n    return declassify_u8s(&new_block);\n}"
BASH: Fn snip "pub fn decrypt(cipher: &[u8], sk: &[U8]) -> Vec<u8> {\n    let mut new_block = [U8::zero(); 8];\n    let classified_cipher = classify_u8s(cipher);\n    for i in 0..8 {\n        new_block[i] = classified_cipher[i] ^ sk[i];\n    }\n    return declassify_u8s(&new_block);\n}"
BASH: Fn snip "fn main() {\n    // Need to handle the simple::get_secret_key() case\n    let secret_key: Vec<secret_integers::U8> = get_secret_key();\n    let mut buffer: String = String::new();\n    println!(\"Please input a 8 byte message\");\n    let _ = io::stdin().read_line(&mut buffer);\n    let mut message = [0u8; 8];\n    for i in 0..8 {\n        if i < buffer.len() {\n            message[i] = buffer.as_bytes()[i];\n        }\n    }\n    let cipher_text: Vec<u8> = encrypt(&message, &secret_key);\n    let text: Vec<u8> = decrypt(&cipher_text, &secret_key);\n    assert!(message == &text[..]);\n    println!(\"message: {:?}\", message);\n    println!(\"ciphertext: {:?}\", cipher_text);\n}"
